# -*- coding: utf-8 -*-
"""treeSolution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F_4kXdGmmGRJPuA8LxnvViP57O7AvjMS
"""

class SolutionTreeForChurner:
     #cette méthode contient:    
     #initialisation de la class SolutionTreeForChurner à partir de l'arbre de décision fourni par l'algorithme de sklearn 
    #guest Cost : data Frame qui doit être préparé par des experts 
    #d'entreprise. Elle contient les types de chaque variable d'entrée 
    #et leur coût 
    #goal: le numéro de classe cible,"0" dans notre cas
    def __init__(self,tree,guestCost,goal,feature_names):
        self.tree=tree
        self.left      = tree.tree_.children_left
        self.right     = tree.tree_.children_right
        self.threshold = tree.tree_.threshold
        self.features  = [feature_names[i] for i in tree.tree_.feature]
        self.value = tree.tree_.value
        
        self.guestCost=guestCost
        self.goal=goal
        self.l=self.left.tolist()
        self.r=self.right.tolist()
    #Des tests utiles pour faciliter le parcour d'une arbre
    def isLeftChild(self,node):
        return node in self.l
    def isRightChild(self,node):
        return node in self.r
    def isRoot(self,node):
        return node==0
    def isLeaf(self,node):
        return self.threshold[node] == -2
    def hasLeftChild(self,node):
        return self.l[node] != -1
    def hasRightChild(self,node):
        return self.r[node] != -1
        
        
    def parent(self,node):
        if self.isRoot(node):
            return 0
        else:
            if self.isLeftChild(node):
                return self.l.index(node)
            else:
                return self.r.index(node)
    #Cette fonction retourne les noeuds cibles dans lesquelles nous allons 
    #essayer de placer tous les individus
    def targetAll(self):

        goals=[]
        
        def recurseSearch(left, right, threshold, features, node, depth,value):
      
            if (not self.isLeaf(node)):
                
                if(self.hasLeftChild(node)):
                    
                    recurseSearch(self.left, self.right, self.threshold, self.features,
                            self.left[node], depth+1,self.value)
                if(self.hasRightChild(node)):
                    recurseSearch(self.left, self.right, self.threshold, self.features,
                            self.right[node], depth+1,self.value)
            else:
                
               
                if value[node][0][self.goal]>0 :
                    
                    goals.append(node)
        recurseSearch(self.left,self.right,self.threshold,self.features,0,0,self.value)
        return goals
    
    def depth(self,index):
  
        depth=0
   
        while(not self.isRoot(index)):
            index=self.parent(index)
            depth+=1
            
        return depth
    #Cette méthode retourne le premier parent en commun pour deux noeuds
    def commonFather(self,node1,node2):
        
        while(node1!=node2):
           
            
            if self.depth(node1)==self.depth(node2):
                node1=self.parent(node1)
                node2=self.parent(node2)
            elif self.depth(node1)<self.depth(node2):
                node2=self.parent(node2)
            else:
                node1=self.parent(node1)
        return node1
        
     
    
    #cette fonction nous renseigne sur la feuille dans lequelle 
    #un utilisateur est plcé après le parcour de l'arbre
    def getResultLeaf(self,user):
        return self.tree.apply(user)
    
    #cette methode retourne le Coût qui permet de passer dans un autre noeud
    def protectionCost(self,users,node_target):
        i=0
        
        nodeUsers=self.getResultLeaf(users)
        costs=[]
        
        for nodeUser in nodeUsers:
            user=users.loc[users.index[i]]
            i=i+1
            node=node_target
            VirtualRoot=self.commonFather(nodeUser,node)
            
            cost=0
            
            while(node!=VirtualRoot):
                node=self.parent(node)
                feature=self.features[node]
                
                
                
               
                if self.guestCost.loc[feature]['type']=='linear':
                    
                    if user[feature]<self.threshold[node]:
                        
                        
                        cost+=(self.threshold[node]-user[feature])*self.guestCost.loc[feature]['increase']
                    else: 
                        
                        cost+=(user[feature]-self.threshold[node])*self.guestCost.loc[feature]['decrease']
                elif self.guestCost.loc[feature]['type']=='class':
                    if user[feature]<self.threshold[node]:
                        
                        cost+=self.guestCost.loc[feature]['increase']
                    else:
                        cost+=self.guestCost.loc[feature]['decrease']
                else :
                    cost+=1000000000
            
            costs.append(cost)

                

        return costs
    #le resultat de cette fonction est :
    #La feuille que le client peut l'atteindre avec le moindre coût
   
    def bestProtectionCost(self,users):
        goals=[]
        for i in users.index:
            user=users.loc[[i]]
            minimunCost=99999999
            bestNode=0
            l=self.targetAll()
            for node in l:
                cost=self.protectionCost(user,node)[0]

                if cost<minimunCost:
                    minimunCost=cost
                    bestNode=node
            goals.append([i,bestNode,minimunCost])
        return goals
    #Cette fonction retourne le coût de protetion de tous les éléments en danger
    def communityProtectionCost(self,users):
        cost=0
        alll=self.bestProtectionCost(users)
        for elem in alll:
            cost+=elem[2]
        return cost
    def communityProtection(self,users):
        import operator
        protections={}
        l=self.bestProtectionCost(users)
        for user in l:
            protections[user[0]]=user[2]
        

        protections = sorted(protections.items(), key=operator.itemgetter(1))
        
        return protections
    #cette methode retourne les clients que l'entreprise peuvent les protéger avec
    #un budget donné en entré
    def bestPractice(self,users,budget):
        userToProtect=[]
        protections=self.communityProtection(users)
        for typle in protections:
            if typle[1]<budget:
                userToProtect.append(typle[0])
                budget-=typle[1]
            else:
                break
        print("You can protect "+ str(len(userToProtect))+
              " from your users with only " + str(budget)+" ." )
        if len(userToProtect) < len(users):
            print("Invest more if you want to protect others .")

# Commented out IPython magic to ensure Python compatibility.
#les bibliotéques nécessaires
import pandas as pd
import numpy as np

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
# %matplotlib inline
df=pd.read_csv("../.csv")
df.drop(columns='Unnamed: 0',axis=1,inplace=True)
df.fillna(0,inplace=True)

from sklearn import tree

clf = tree.DecisionTreeClassifier()
X=df.drop(columns='flag_churn',axis=1)
y=df['flag_churn']

clf.fit(X, y)

#nous allons essayer de remplir la dataFrame pour pouvoir tester l'algorithmes 
#après c'est l'affaire de l'entreprise de le préparer afin d'avoir des bons résultas

guest=pd.DataFrame(index=X.columns,columns=['type','increase','decrease'])
guest['type']='linear'
guest['increase']=5
guest['decrease']=2

solution=SolutionTreeForChurner(clf,guest,0,X.columns)

a=solution.bestPractice(x1,20)

















